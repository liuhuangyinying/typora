---
typora-root-url: ./
---

[TOC]



# 多线程基础

## 并发和并行

并行是指两个或者多个事件在同一时刻发生；多CPU支持；

并发是指单位时间内能够同时处理的请求数；CPU时间片切换；

默认情况下Tomcat可以支持的最大请求数是150，当超过这个并发数的时候，就会开始导致响应延迟，连接丢失等问题。



## 线程作用

提升服务器端的并发数量（吞吐量）。



## 影响服务器吞吐量的因素

硬件：CPU、内存、磁盘、网络

软件：线程数量、JVM内存分配大小、磁盘IO、网络通信机制（BIO、NIO、AIO）



## JAVA中的线程

- Runnable 接口

  ```java
  public interface Runnable {
      public abstract void run();
  }
  ```

- Thread 类

- Callable 接口

  ```java
  public interface Callable<V> {
      V call() throws Exception;
  }
  ```

- ExecutorService 接口 线程池

  四种线程池

  `newCachedThreadPool`创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

1. ```java
   ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
   for (int i = 0; i < 10; i++) {
       final int index = i;
       try {
           Thread.sleep(index * 1000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
       
       cachedThreadPool.execute(()->{
                   System.out.println(index);
       });
   }
   ```

   > 线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。

2. `newFixedThreadPool` 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

   ```java
   ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
       for (int i = 0; i < 10; i++) {
           final int index = i;
           fixedThreadPool.execute(()->{
               try {
                   System.out.println(index);
                   Thread.sleep(2000);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           });
   }
   ```

   > 因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。
   > 定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。

3. `newScheduledThreadPool` 创建一个定长线程池，支持定时及周期性任务执行。

   ```java
   ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
   
   // 表示延迟3秒执行
   scheduledThreadPool.schedule(()->{
       System.out.println("delay 3 seconds");
   }, 3, TimeUnit.SECONDS);
   
   // 表示延迟1秒后每3秒执行一次
   scheduledThreadPool.scheduleAtFixedRate(()-> {
       System.out.println("delay 1 seconds, and excute every 3 seconds");
   }, 1, 3, TimeUnit.SECONDS);
   ```

   

4. `newSingleThreadExecutor` 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

   ```java
   ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
   for (int i = 0; i < 10; i++) {
       final int index = i;
       singleThreadExecutor.execute(()-> {
           try {
               System.out.println(index);
               Thread.sleep(2000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       });
   }
   ```

   

## Thread应用场景

- 网络请求分发的场景
- 文件导入
- 短信发送场景



## Java线程生命周期

![线程生命周期](/多线程笔记.assets/Java线程生命周期.png)

需要注意的是，操作系统中的线程除去 new 和 terminated 状态，一个线程真实存在的状态，只有：

- `ready` ：表示线程已经被创建，正在等待系统调度分配CPU使用权。 

- `running` ：表示线程获得了CPU使用权，正在进行运算 

- `waiting` ：表示线程等待（或者说挂起），让出CPU资源给其他线程使用

在加上新建状态和死亡状态，一共5种



## 线程的启动

```java
new Thread(()->{
    System.out.println("启动线程");
}).start();
```

> start启动线程，run调用实例方法

![线程启动](/多线程笔记.assets/线程启动.png)



## 线程的终止

> 线程什么情况下会终止

run方法执行结束 volatile jint _interrupted;     <!--Thread.isInterrupted state-->

```c
void os::interrupt(Thread* thread) {  
    assert(Thread::current() == thread || Threads_lock->owned_by_self(),    
           "possibility of dangling Thread pointer");
  OSThread* osthread = thread->osthread();
  if (!osthread->interrupted()) {    
      osthread->set_interrupted(true); //设置一个中断状态    
      // More than one thread can get here with the same value of osthread,    
      // resulting in multiple notifications.  We do, however, want the store    
      // to interrupted() to be visible to other threads before we execute unpark().   
      OrderAccess::fence();    
      ParkEvent * const slp = thread->_SleepEvent ;//如果是sleep中，唤醒    
      if (slp != NULL) slp->unpark() ;  
  }
   // For JSR166. Unpark even if interrupt status already was set  
   if (thread->is_Java_thread())    ((JavaThread*)thread)->parker()->unpark();
   ParkEvent * ev = thread->_ParkEvent ;  if (ev != NULL) ev->unpark() ;
}
```



## interrupt()的作用 

- 设置一个共享变量的值 true 

- 唤醒处于阻塞状态下的线程

  只有唤醒状态下的线程,JVM抛出InterruptedException异常才能被线程捕获,从而做出响应(中断线程,抛出异常或者不处理)

> 正确的终止线程不是由外部去决定,而是将终止决定权交由程序线程自己决定,而非强制终止.

> 所有线程阻塞操作(sleep/wait/join)都要捕获InterruptedException以对中断作出响应处理

```java
Thread thread = new Thread(()->{
    while (!Thread.currentThread().isInterrupted()){
    }
    System.out.println("线程结束");
});
thread.start();
// 发起中断请求
thread.interrupt();
```

> 号外号外：：
>
> ReentrantLock

# 线程安全

线程安全：

- 原子性：线程不允许被中断
- 有序性：
- 可见性：CPU告诉缓存机制+引入storebuffer

## 原子性、可见性案例

```java
public static int count = 0 ;

public static void incr(){
    try {
        Thread.sleep(1000);
        count ++;
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
public static void main(String[] args) {
    for(int i = 0 ;i < 1000 ; i++){
        new Thread(()->{
            incr();
        }).start();
    }
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(count);
}
```

结果是小于等于1000的随机数

原因：可见性、原子性

## 非原子性：count++指令

```assembly
14: getstatic     #5  // Field count:I 
15: iconst_1 
16: iadd 
17: putstatic     #5 
```

多线程环境中，CPU切换上下文，count++指令可能被中断，因此会出现



## 同步锁Synchronized

> 互斥锁的本质：共享资源。

- 类锁（作用范围大，性能开销大）
- 对象锁



### 锁的作用范围

synchronized有三种方式来加锁，不同的修饰类型，代表锁的控制粒度：

1. 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 
2. 静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

### 锁的存储（对象头）：

![Synchronized存储](/多线程笔记.assets/Synchronized存储.png)

### 打印类的布局

```xml
![锁升级](/多线程笔记.assets/锁升级.png) <dependency>      
     <groupId>org.openjdk.jol</groupId>      
     <artifactId>jol-core</artifactId>      
     <version>0.10</version>    
</dependency>
```

通过打印加锁类来查看对象头 

```java
SynchronizedTest classLayoutDemo=new SynchronizedTest();
synchronized (classLayoutDemo){
    System.out.println("locking");
    System.out.println(ClassLayout.parseInstance(classLayoutDemo).toPrintable());
}
```



### 锁的升级

锁升级：

偏向锁 -> 轻量级锁（乐观锁，自旋锁） ->  重量级锁（ 监视器）

CAS          多次CAS

> 线程获得锁和释放锁时间很短暂，因此通过自旋（CAS）很大概率可以获得锁
>
> 自旋可能带来CPU性能开销，因此需要控制自旋次数
>
> JDK1.6以前默认自旋10次
>
> JDK1.6以后自适应自旋

![](/多线程笔记.assets/锁升级.png)

### 偏向锁

在大多数情况下，锁不仅仅不存在多线程的竞争，而且总是由同一个线程多次获得。在这个背景下就设 计了偏向锁。偏向锁，顾名思义，就是锁偏向于某个线程。
当一个线程访问加了同步锁的代码块时，会在对象头中存储当前线程的ID，后续这个线程进入和退出这 段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线 程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，引入偏向锁是为了 在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。（偏向锁的目的是消除数据在无竞争情 况下的同步原语，进一步提高程序的运行性能。）

### 轻量级

如果偏向锁被关闭或者当前偏向锁已经已经被其他线程获取，那么这个时候如果有线程去抢占同步锁时，锁会升级到轻量级锁。 

### 重量级锁

- 多个线程竞争同一个锁的时候，虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒 这些线程；

- Java 线程的阻塞以及唤醒，都是依靠操作系统来完成的：os pthread_mutex_lock() ； 

- 升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态

每一个JAVA对象都会与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执行 一段被synchronized修饰的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象对应的monitor。 monitorenter表示去获得一个对象监视器。monitorexit表示释放monitor监视器的所有权，使得其他被阻塞的线程可以尝试去获得这个监视器
monitor依赖操作系统的MutexLock(互斥锁)来实现的,线程被阻塞后便进入内核（Linux）调度状态，这 个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能
任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。

![](/多线程笔记.assets/重量级锁.png)



**总结** 

- 偏向锁只有在第一次请求时采用CAS在锁对象的标记中记录当前线程的地址，在之后该线程再次进 入同步代码块时，不需要抢占锁，直接判断线程ID即可，这种适用于锁会被同一个线程多次抢占 的情况。 

- 轻量级锁才用CAS操作，把锁对象的标记字段替换为一个指针指向当前线程栈帧中的 LockRecord，该工件存储锁对象原本的标记字段，它针对的是多个线程在不同时间段内申请通一 把锁的情况。

- 重量级锁会阻塞、和唤醒加锁的线程，它适用于多个线程同时竞争同一把锁的情况。



## 线程的通信(wait/notify）

在Java中提供了wait/notify这个机制，用来实现条件等待和唤醒。这个机制我们平时工作中用的少，但是在很多底层源码中有用到。

比如以抢占锁为例，假设线程A持有锁，线程B再去抢占锁时，它需要等待持有锁的线程释放之后才能抢占，那线程B怎么知道线程A什么时候释放呢？

这个时候就可以采用通信机制。

![](/多线程笔记.assets/线程的通信.png)



## 一个可见性问题引发的思考

```java
private static boolean stop = false;
public static void main(String[] args) {
    Thread thread = new Thread(() -> {
        int i = 0;
        while (!stop) {
            i++;
        }
    });
    thread.start();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stop = true;
}
```

问题描述:

共享变量stop,主线程在子线程启动后修改stop,子线程无法感知stop变化,一直循环执行.这是可见性问题.

解决方案:

+ 共享变量stop使用volatile修饰

```java
private volatile static boolean stop = false;
```

+ 子线程使用sleep/synchronized/print/文件(IO)操作

  > sleep Happens-Before原则

```java
private static boolean stop = false;
public static void main(String[] args) {
    Thread thread = new Thread(() -> {
        int i = 0;
        while (!stop) {
            i++;
            try {
                Thread.sleep(0);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
    thread.start();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stop = true;
}
```

> print两个操作：IO阻塞，synchronized

```java
private static boolean stop = false;
public static void main(String[] args) {
    Thread thread = new Thread(() -> {
        int i = 0;
        while (!stop) {
            i++;
            System.out.println("可见性解决");
        }
    });
    thread.start();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stop = true;
}
```

为什么print可以导致循环结束？

先来看看print的底层实现

```java
public void println() {
    newLine();
}    
private void newLine() {
    try {
        synchronized (this) {
            ensureOpen();
            textOut.newLine();
            textOut.flushBuffer();
            charOut.flushBuffer();
            if (autoFlush)
                out.flush();
        }
    }
    catch (InterruptedIOException x) {
        Thread.currentThread().interrupt();
    }
    catch (IOException x) {
        trouble = true;
    }
}
```

这里分为三个层面来解答：

- println底层用了synchronized同步关键字，这个同步会防止循环期间对于stop的缓存。
- println有加锁操作，而释放锁的操作，会强制性的把工作内存中涉及到的写操作同步到主内存。
- 从IO角度上看，print本质上是一个IO的操作。磁盘IO的效率一定要比CPU的计算效率慢得多，所以IO可以使得CPU有时间去做内存刷新的事情，从而导致这个现象。

IO阻塞

```java
private static boolean stop = false;
public static void main(String[] args) {
    Thread thread = new Thread(() -> {
        int i = 0;
        while (!stop) {
            i++;
            new File("E://a.txt");
        }
    });
    thread.start();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stop = true;
}
```



## 使用volatile保证可见性

在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那 这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程 环境下，读和写发生在不同的线程中的时候，可能会出现：读线程不能及时的读取到其他线程写入的最 新的值。这就是所谓的可见性

volatile:通过内存屏障禁止指令重排序

Lock => 等价于内存平账

不同操作系统，不同CPU提供不同内存屏障指令，JVM提供统一接口处理，提供给JAVA高级指令volatile保证可见性。



## 从硬件层面分析可见性问题的本质

硬件：CPU，内存，IO设备

- CPU层面增加了高速缓存
- 操作系统，进程、线程|CPU时间片切换
- 编译器的优化，更合理的利用CPU缓存

CPU优化->新增高速缓存->出现缓存一致性问题->MESI协议解决缓存一致性问题->MESI通知失效会有阻塞->引入storebuffer实现异步通知失效->带来指令重排序问题

### CPU层面的高速缓存

> 缓存一致性问题

非统一内存访问架构

![](/多线程笔记.assets/非统一内存访问架构.png)

> ### 总线锁&缓存锁 
>
> 总线锁，简单来说就是，在多cpu下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出 一个LOCK#信号，这个信号使得其他处理器无法通过总线来访问到共享内存中的数据，总线锁定把CPU 和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定 的开销比较大，这种机制显然是不合适的 。 
>
> 如何优化呢？最好的方法就是控制锁的保护粒度，我们只需要保证对于被多个CPU缓存的同一份数据是 一致的就行。
>
> 在P6架构的CPU后，引入了缓存锁，如果当前数据已经被CPU缓存了，并且是要协会到主 内存中的，就可以采用缓存锁来解决问题。
> 所谓的缓存锁，就是指内存区域如果被缓存在处理器的缓存行中，并且在Lock期间被锁定，那么当它执 行锁操作回写到内存时，不再总线上加锁，而是修改内部的内存地址，基于缓存一致性协议来保证操作 的原子性。
> 总线锁和缓存锁怎么选择，取决于很多因素，比如CPU是否支持、以及存在无法缓存的数据时 （比较大或者快约多个缓存行的数据），必然还是会使用总线锁。 

## MESI优化带来的指令重排序问题

### 缓存一致性协议：MESI

> 带来问题：通知失效出现短暂阻塞

MSI  ，MESI 、MOSI ...
为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常 见的协议有MSI，MESI，MOSI等。

最常见的就是MESI协议，MESI表示缓存行的四种状态，分别是

1. M(Modify) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的数据和主内 存中的数据不一致
2. E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改
3. S(Shared) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致
4. I(Invalid) 表示缓存已经失效

![](/多线程笔记.assets/缓存一致性.png)

### MESI通知失效阻塞优化：引入StoreBuffers

> 带来问题：指令重排序

Store Buﬀeres是一个写的缓冲，对于上述描述的情况，CPU0可以先把写入的操作先存储到Store Buﬀeres中，Store Buﬀeres中的指令再按照缓存一致性协议去发起其他CPU缓存行的失效。而同步来 说CPU0可以不用等到Acknowledgement，继续往下执行其他指令，直到收到CPU0收到 Acknowledgement再更新到缓存，再从缓存同步到主内存.

![](/多线程笔记.assets/引入storebuffers.png)



### 指令重排序

我们来关注下面这段代码，假设分别有两个线程，分别执行executeToCPU0和executeToCPU1，分别由两个不同的CPU来执行。 

引入Store Buﬀeres之后，就可能出现 b==1返回true ，但是assert(a==1)返回false。

很多同学肯定会表 示不理解，这种情况怎么可能成立？那接下来我们去分析一下。

```java

```





## 从JMM层面了解可见性





## 从Java回归到volatile本质



## Happens-Before可见性模型





# 工具

## HSDIS工具：查看汇编指令

> 查看运行代码的汇编指令的工具.zip

1. 解压压缩文件放到`JRE_HOME/bin/server`路径下

   比如：C:\Program Files\Java\jdk1.8.0_202\jre\bin\server

2. 在运行main函数之前，加入虚拟机参数

> -server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*App.getInstance（替换成实际运行的代码） 

