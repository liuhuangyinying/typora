---
typora-root-url: ./
---

[TOC]



# 多线程基础

## 并发和并行

并行是指两个或者多个事件在同一时刻发生；多CPU支持；

并发是指单位时间内能够同时处理的请求数；CPU时间片切换；

默认情况下Tomcat可以支持的最大请求数是150，当超过这个并发数的时候，就会开始导致响应延迟，连接丢失等问题。



## 线程作用

提升服务器端的并发数量（吞吐量）。



## 影响服务器吞吐量的因素

硬件：CPU、内存、磁盘、网络

软件：线程数量、JVM内存分配大小、磁盘IO、网络通信机制（BIO、NIO、AIO）



## JAVA中的线程

- Runnable 接口

  ```java
  public interface Runnable {
      public abstract void run();
  }
  ```

- Thread 类

- Callable 接口

  ```java
  public interface Callable<V> {
      V call() throws Exception;
  }
  ```

- ExecutorService 接口 线程池

  四种线程池

  `newCachedThreadPool`创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

1. ```java
   ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
   for (int i = 0; i < 10; i++) {
       final int index = i;
       try {
           Thread.sleep(index * 1000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
       
       cachedThreadPool.execute(()->{
                   System.out.println(index);
       });
   }
   ```

   > 线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。

2. `newFixedThreadPool` 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

   ```java
   ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
       for (int i = 0; i < 10; i++) {
           final int index = i;
           fixedThreadPool.execute(()->{
               try {
                   System.out.println(index);
                   Thread.sleep(2000);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           });
   }
   ```

   > 因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。
   > 定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。

3. `newScheduledThreadPool` 创建一个定长线程池，支持定时及周期性任务执行。

   ```java
   ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
   
   // 表示延迟3秒执行
   scheduledThreadPool.schedule(()->{
       System.out.println("delay 3 seconds");
   }, 3, TimeUnit.SECONDS);
   
   // 表示延迟1秒后每3秒执行一次
   scheduledThreadPool.scheduleAtFixedRate(()-> {
       System.out.println("delay 1 seconds, and excute every 3 seconds");
   }, 1, 3, TimeUnit.SECONDS);
   ```

   

4. `newSingleThreadExecutor` 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

   ```java
   ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
   for (int i = 0; i < 10; i++) {
       final int index = i;
       singleThreadExecutor.execute(()-> {
           try {
               System.out.println(index);
               Thread.sleep(2000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       });
   }
   ```

   

## Thread应用场景

- 网络请求分发的场景
- 文件导入
- 短信发送场景



## Java线程生命周期

![线程生命周期](/多线程笔记.assets/Java线程生命周期.png)

需要注意的是，操作系统中的线程除去 new 和 terminated 状态，一个线程真实存在的状态，只有：

- `ready` ：表示线程已经被创建，正在等待系统调度分配CPU使用权。 

- `running` ：表示线程获得了CPU使用权，正在进行运算 

- `waiting` ：表示线程等待（或者说挂起），让出CPU资源给其他线程使用

在加上新建状态和死亡状态，一共5种



## 线程的启动

```java
new Thread(()->{
    System.out.println("启动线程");
}).start();
```

> start启动线程，run调用实例方法

![线程启动](/多线程笔记.assets/线程启动.png)



## 线程的终止

> 线程什么情况下会终止

run方法执行结束 volatile jint _interrupted;     <!--Thread.isInterrupted state-->

```c
void os::interrupt(Thread* thread) {  
    assert(Thread::current() == thread || Threads_lock->owned_by_self(),    
           "possibility of dangling Thread pointer");
  OSThread* osthread = thread->osthread();
  if (!osthread->interrupted()) {    
      osthread->set_interrupted(true); //设置一个中断状态    
      // More than one thread can get here with the same value of osthread,    
      // resulting in multiple notifications.  We do, however, want the store    
      // to interrupted() to be visible to other threads before we execute unpark().   
      OrderAccess::fence();    
      ParkEvent * const slp = thread->_SleepEvent ;//如果是sleep中，唤醒    
      if (slp != NULL) slp->unpark() ;  
  }
   // For JSR166. Unpark even if interrupt status already was set  
   if (thread->is_Java_thread())    ((JavaThread*)thread)->parker()->unpark();
   ParkEvent * ev = thread->_ParkEvent ;  if (ev != NULL) ev->unpark() ;
}
```



## interrupt()的作用 

- 设置一个共享变量的值 true 

- 唤醒处于阻塞状态下的线程

  只有唤醒状态下的线程,JVM抛出InterruptedException异常才能被线程捕获,从而做出响应(中断线程,抛出异常或者不处理)

> 正确的终止线程不是由外部去决定,而是将终止决定权交由程序线程自己决定,而非强制终止.

> 所有线程阻塞操作(sleep/wait/join)都要捕获InterruptedException以对中断作出响应处理

```java
Thread thread = new Thread(()->{
    while (!Thread.currentThread().isInterrupted()){
    }
    System.out.println("线程结束");
});
thread.start();
// 发起中断请求
thread.interrupt();
```



# 线程安全

## 一个可见性问题引发的思考

```java
private static boolean stop = false;
public static void main(String[] args) {
    Thread thread = new Thread(() -> {
        int i = 0;
        while (!stop) {
            i++;
        }
    });
    thread.start();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stop = true;
}
```

问题描述:

共享变量stop,主线程在子线程启动后修改stop,子线程无法感知stop变化,一直循环执行.这是可见性问题.

解决方案:

+ 共享变量stop使用volatile修饰

```java
private volatile static boolean stop = false;
```

+ 子线程使用sleep/print/文件(IO)操作

  > sleep Happens-Before原则,

```java
private static boolean stop = false;
public static void main(String[] args) {
    Thread thread = new Thread(() -> {
        int i = 0;
        while (!stop) {
            i++;
            try {
                Thread.sleep(0);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
    thread.start();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stop = true;
}
```



## 使用volatile保证可见性





## 从硬件层面分析可见性问题的本质





## MESI优化带来的指令重排序问题





## 从JMM层面了解可见性





## 从Java回归到volatile本质



## Happens-Before可见性模型



