---
typora-root-url: ./
---

# 多线程

## 并发和并行

并行是指两个或者多个事件在同一时刻发生；多CPU支持；

并发是指单位时间内能够同时处理的请求数；CPU时间片切换；

默认情况下Tomcat可以支持的最大请求数是150，当超过这个并发数的时候，就会开始导致响应延迟，连接丢失等问题。



## 线程作用

提升服务器端的并发数量（吞吐量）。



## 影响服务器吞吐量的因素

硬件：CPU、内存、磁盘、网络

软件：线程数量、JVM内存分配大小、磁盘IO、网络通信机制（BIO、NIO、AIO）



## JAVA中的线程

- Runnable 接口

  ```java
  public interface Runnable {
      public abstract void run();
  }
  ```

- Thread 类

- Callable 接口

  ```java
  public interface Callable<V> {
      V call() throws Exception;
  }
  ```

- ExecutorService 接口 线程池

  四种线程池

  `newCachedThreadPool`创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

1. ```java
   ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
   for (int i = 0; i < 10; i++) {
       final int index = i;
       try {
           Thread.sleep(index * 1000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
       
       cachedThreadPool.execute(()->{
                   System.out.println(index);
       });
   }
   ```

   > 线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。

2. `newFixedThreadPool` 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

   ```java
   ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
       for (int i = 0; i < 10; i++) {
           final int index = i;
           fixedThreadPool.execute(()->{
               try {
                   System.out.println(index);
                   Thread.sleep(2000);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           });
   }
   ```

   > 因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。
   > 定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。

3. `newScheduledThreadPool` 创建一个定长线程池，支持定时及周期性任务执行。

   ```java
   ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
   
   // 表示延迟3秒执行
   scheduledThreadPool.schedule(()->{
       System.out.println("delay 3 seconds");
   }, 3, TimeUnit.SECONDS);
   
   // 表示延迟1秒后每3秒执行一次
   scheduledThreadPool.scheduleAtFixedRate(()-> {
       System.out.println("delay 1 seconds, and excute every 3 seconds");
   }, 1, 3, TimeUnit.SECONDS);
   ```

   

4. `newSingleThreadExecutor` 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

   ```java
   ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
   for (int i = 0; i < 10; i++) {
       final int index = i;
       singleThreadExecutor.execute(()-> {
           try {
               System.out.println(index);
               Thread.sleep(2000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       });
   }
   ```

   

## Thread应用场景

- 网络请求分发的场景
- 文件导入
- 短信发送场景



## Java线程生命周期

![线程生命周期](/多线程笔记.assets/Java线程生命周期.png)

需要注意的是，操作系统中的线程除去 new 和 terminated 状态，一个线程真实存在的状态，只有：

- `ready` ：表示线程已经被创建，正在等待系统调度分配CPU使用权。 

- `running` ：表示线程获得了CPU使用权，正在进行运算 

- `waiting` ：表示线程等待（或者说挂起），让出CPU资源给其他线程使用

在加上新建状态和死亡状态，一共5种



## 线程的启动

```java
new Thread(()->{
    System.out.println("启动线程");
}).start();
```

> start启动线程，run调用实例方法

![线程启动](/多线程笔记.assets/线程启动.png)



## 线程的终止

> 线程什么情况下会终止

run方法执行结束 volatile jint _interrupted;     <!--Thread.isInterrupted state-->

```c
void os::interrupt(Thread* thread) {  
    assert(Thread::current() == thread || Threads_lock->owned_by_self(),    
           "possibility of dangling Thread pointer");
  OSThread* osthread = thread->osthread();
  if (!osthread->interrupted()) {    
      osthread->set_interrupted(true); //设置一个中断状态    
      // More than one thread can get here with the same value of osthread,    
      // resulting in multiple notifications.  We do, however, want the store    
      // to interrupted() to be visible to other threads before we execute unpark().    OrderAccess::fence();    ParkEvent * const slp = thread->_SleepEvent ; //如果是sleep中，唤醒    if (slp != NULL) slp->unpark() ;  }
  // For JSR166. Unpark even if interrupt status already was set  if (thread->is_Java_thread())    ((JavaThread*)thread)->parker()->unpark();
  ParkEvent * ev = thread->_ParkEvent ;  if (ev != NULL) ev->unpark() ;
}
```



## interrupt()的作用 

- 设置一个共享变量的值 true 

- 唤醒处于阻塞状态下的线程。